# First-Order Logic

**基础**: 谓词逻辑、形式逻辑  
**应用**: 论证分析、形式验证  
**类型**: 逻辑与认知  
**优先级**: P0

---

## 核心概念

### 逻辑体系

```
┌─────────────────────────────────────────────┐
│               逻辑层级                       │
├─────────────────────────────────────────────┤
│                                             │
│  命题逻辑 (Propositional)                   │
│  ├─ 原子命题: P, Q, R                       │
│  ├─ 连接词: ∧(且), ∨(或), ¬(非), →(蕴含)   │
│  └─ 例: 下雨 → 地湿                         │
│                                             │
│  一阶谓词逻辑 (First-Order)                 │
│  ├─ 个体: a, b, c                           │
│  ├─ 谓词: P(x), Q(x,y)                      │
│  ├─ 量词: ∀(所有), ∃(存在)                  │
│  └─ 例: ∀x(人(x) → 会死(x))                │
│                                             │
│  高阶逻辑 (Higher-Order)                    │
│  └─ 谓词的谓词、量化谓词                    │
│                                             │
└─────────────────────────────────────────────┘
```

### 一阶逻辑语法

**基本元素**:
```
1. 个体常量: a, b, c (指特定对象)
2. 个体变量: x, y, z (泛指对象)
3. 谓词符号: P, Q, R (表示属性或关系)
   ├─ 一元谓词: P(x) - "x是P"
   ├─ 二元谓词: R(x,y) - "x与y有R关系"
   └─ n元谓词: P(x₁,...,xₙ)
4. 函数符号: f, g (映射个体到个体)
5. 量词:
   ├─ ∀ (全称量词): "对于所有"
   └─ ∃ (存在量词): "存在至少一个"
6. 连接词:
   ├─ ¬ (否定): 非P
   ├─ ∧ (合取): P且Q
   ├─ ∨ (析取): P或Q
   ├─ → (蕴含): 如果P则Q
   └─ ↔ (等价): P当且仅当Q
```

---

## 论证拆解框架

### 标准论证结构

```
论证: 前提 → 结论

形式化模板:
├─ 前提1: P(a) [谓词应用于个体]
├─ 前提2: ∀x(P(x) → Q(x)) [一般规律]
└─ 结论: Q(a) [应用得出]

例:
├─ 前提1: 苏格拉底是人
├─ 前提2: 所有人都是会死的
└─ 结论: 苏格拉底是会死的

形式化:
├─ 人(苏格拉底)
├─ ∀x(人(x) → 会死(x))
└─ 会死(苏格拉底)
```

### 复杂论证拆解

```
商业论证示例:

原文:
"我们所有的竞争对手都在降价，
如果我们不跟进，就会失去市场份额。
因此，我们必须降价。"

拆解:
1. 识别谓词
   ├─ 降价(x): 公司x在降价
   ├─ 竞争对手(x): x是我们的竞争对手
   ├─ 失去份额: 我们会失去市场份额
   └─ 必须(行动): 我们应该采取某行动

2. 形式化
   ├─ 前提1: ∀x(竞争对手(x) → 降价(x))
   ├─ 前提2: ¬降价(我们) → 失去份额
   ├─ 前提3: ¬可接受(失去份额)
   └─ 结论: 降价(我们)

3. 逻辑检验
   ├─ 前提1是否真实? (数据支持?)
   ├─ 前提2是否必然? (差异化可能?)
   ├─ 前提3是否成立? (份额vs利润权衡)
   └─ 是否存在隐含前提?
```

---

## 逻辑有效性检验

### 推理规则

```
1. 假言推理 (Modus Ponens)
   P → Q
   P
   ─────
   ∴ Q

2. 拒取式 (Modus Tollens)
   P → Q
   ¬Q
   ─────
   ∴ ¬P

3. 三段论 (Syllogism)
   ∀x(P(x) → Q(x))
   P(a)
   ─────────────
   ∴ Q(a)

4. 消解原理 (Resolution)
   P ∨ Q
   ¬P ∨ R
   ───────
   ∴ Q ∨ R
```

### 常见逻辑谬误

```
形式谬误 (结构错误):

1. 肯定后件
   P → Q
   Q
   ───── [无效]
   ∴ P
   
   例: 如果下雨地湿，地湿了，所以下雨了。
   (可能是洒水车)

2. 否定前件
   P → Q
   ¬P
   ───── [无效]
   ∴ ¬Q
   
   例: 如果下雨地湿，没下雨，所以地不湿。
   (可能还有其他原因)

3. 四词项错误
   所有A是B
   所有C是B
   ───────── [无效]
   所有A是C

4. 不当换位
   所有A是B
   ──────── [无效]
   所有B是A
```

---

## Kbot论证分析框架

### /analyze 命令

```
/analyze "论证文本"

输出格式:
┌─────────────────────────────────────────────┐
│ 原始论证                                    │
│ [原文]                                      │
├─────────────────────────────────────────────┤
│ 谓词识别                                    │
│ ├─ P(x): [定义]                            │
│ ├─ Q(x): [定义]                            │
│ └─ ...                                     │
├─────────────────────────────────────────────┤
│ 形式化结构                                  │
│ 前提1: [逻辑表达式]                         │
│ 前提2: [逻辑表达式]                         │
│ 结论: [逻辑表达式]                          │
├─────────────────────────────────────────────┤
│ 有效性检验                                  │
│ ├─ 形式有效性: [有效/无效]                  │
│ ├─ 前提真实性: [待验证]                     │
│ └─ 推理规则: [正确/错误]                    │
├─────────────────────────────────────────────┤
│ 隐含假设                                    │
│ ├─ 假设1: [未明说的前提]                    │
│ └─ 假设2: [未明说的前提]                    │
├─────────────────────────────────────────────┤
│ 逻辑漏洞                                    │
│ ├─ 漏洞1: [描述] [严重程度]                 │
│ └─ 建议: [如何修正]                         │
├─────────────────────────────────────────────┤
│ 置信度评估                                  │
│ 结论可信度: [0-100%]                        │
│ 证据强度: [强/中/弱]                        │
│ 建议行动: [接受/质疑/拒绝]                  │
└─────────────────────────────────────────────┘
```

### 应用示例

```
输入:
"我们的产品比竞品便宜20%，
所以客户一定会选择我们。"

分析:
┌─────────────────────────────────────────────┐
│ 谓词识别                                    │
│ ├─ 便宜(x,y): x比y便宜                      │
│ ├─ 选择(x,y): 客户选择x而非y                │
│ └─ 一定(x): x必然发生                       │
├─────────────────────────────────────────────┤
│ 形式化                                      │
│ 前提: 便宜(我们, 竞品) ∧ 便宜幅度=20%       │
│ 结论: 一定(选择(客户, 我们))                │
│ 隐含: 便宜(我们,竞品) → 选择(客户,我们)     │
├─────────────────────────────────────────────┤
│ 逻辑检验                                    │
│ ├─ 形式: 有效 (肯定前件式)                  │
│ ├─ 隐含前提: 价格是唯一决定因素 ← 存疑!     │
│ └─ 结论强度: 一定 ← 过度概括!               │
├─────────────────────────────────────────────┤
│ 漏洞识别                                    │
│ 1. 忽略其他因素: 质量、品牌、服务           │
│ 2. 过度概括: "一定"过于绝对                 │
│ 3. 样本偏差: 假设所有客户都是价格敏感型     │
├─────────────────────────────────────────────┤
│ 修正建议                                    │
│ "价格优势可能吸引价格敏感客户，              │
│  但需配合质量证明才能打动高端客户"          │
└─────────────────────────────────────────────┘
```

---

## 形式验证应用

### 算法正确性证明

```
功能: 验证程序逻辑正确性

方法:
1. 前置条件: 程序执行前的状态约束
2. 后置条件: 程序执行后的状态约束
3. 不变式: 循环中始终保持的约束

例: 数组求和
```
function sum(arr):
    // 前置: arr是数值数组
    s = 0
    i = 0
    while i < length(arr):
        // 不变式: s = sum(arr[0..i-1])
        s = s + arr[i]
        i = i + 1
    // 后置: s = sum(arr[0..length-1])
    return s
```
```

### 合同规范

```
设计By Contract:
├─ 前置条件 (Require): 调用者保证
├─ 后置条件 (Ensure): 被调用者保证
└─ 不变式 (Invariant): 始终保证

例: 转账函数
```
function transfer(from, to, amount):
    Require: balance(from) ≥ amount
    Require: amount > 0
    
    balance(from) -= amount
    balance(to) += amount
    
    Ensure: balance(from) = old(balance(from)) - amount
    Ensure: balance(to) = old(balance(to)) + amount
    Ensure: total_balance = old(total_balance)  // 不变式
```
```

---

*逻辑是思维的语法，论证的质量取决于结构的严谨。*
