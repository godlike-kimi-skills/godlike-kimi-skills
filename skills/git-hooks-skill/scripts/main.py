#!/usr/bin/env python3
"""
Git Hooks Management Skill
Supports: pre-commit, pre-push, Husky configuration, custom hooks
"""

import os
import sys
import json
import argparse
import subprocess
import stat
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from pathlib import Path
from enum import Enum
import shutil

# ============================================================================
# Hook Templates
# ============================================================================

PRE_COMMIT_HOOK_TEMPLATE = '''#!/bin/sh
# Pre-commit hook generated by git-hooks-skill
# This hook runs before each commit

echo "Running pre-commit checks..."

# Run linting
{lint_command}

# Run tests
{test_command}

# Check for secrets/keys
{secret_check_command}

if [ $? -ne 0 ]; then
    echo "Pre-commit checks failed. Commit aborted."
    exit 1
fi

exit 0
'''

PRE_PUSH_HOOK_TEMPLATE = '''#!/bin/sh
# Pre-push hook generated by git-hooks-skill
# This hook runs before each push

echo "Running pre-push checks..."

# Run full test suite
{test_command}

# Check branch protection
{branch_check_command}

if [ $? -ne 0 ]; then
    echo "Pre-push checks failed. Push aborted."
    exit 1
fi

exit 0
'''

COMMIT_MSG_HOOK_TEMPLATE = '''#!/bin/sh
# Commit-msg hook for validating commit messages
# This hook validates the format of commit messages

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat $1)

# Check commit message format
{validation_logic}

if [ $? -ne 0 ]; then
    echo "Invalid commit message format."
    echo "Expected format: {format_pattern}"
    exit 1
fi

exit 0
'''

PYTHON_HOOK_TEMPLATE = '''#!/usr/bin/env python3
# Python-based git hook generated by git-hooks-skill

import sys
import subprocess

def main():
    print("Running {hook_name} hook...")
    
    {hook_logic}
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
'''

HUSKY_CONFIG_TEMPLATE = '''{
  "hooks": {
    "pre-commit": "{pre_commit_cmd}",
    "pre-push": "{pre_push_cmd}",
    "commit-msg": "{commit_msg_cmd}",
    "post-checkout": "{post_checkout_cmd}",
    "post-merge": "{post_merge_cmd}"
  }
}
'''

# ============================================================================
# Data Classes
# ============================================================================

class HookType(Enum):
    """Git hook types"""
    PRE_COMMIT = "pre-commit"
    PRE_PUSH = "pre-push"
    PRE_REBASE = "pre-rebase"
    POST_CHECKOUT = "post-checkout"
    POST_COMMIT = "post-commit"
    POST_MERGE = "post-merge"
    POST_REWRITE = "post-rewrite"
    COMMIT_MSG = "commit-msg"
    PREPARE_COMMIT_MSG = "prepare-commit-msg"
    APPLYPATCH_MSG = "applypatch-msg"
    PRE_APPLYPATCH = "pre-applypatch"
    POST_APPLYPATCH = "post-applypatch"
    PRE_MERGE_COMMIT = "pre-merge-commit"

@dataclass
class HookConfig:
    """Git hook configuration"""
    hook_type: HookType
    enabled: bool = True
    command: str = ""
    use_python: bool = False
    fail_on_error: bool = True
    custom_logic: str = ""

@dataclass
class CommitMessageConfig:
    """Commit message validation configuration"""
    enabled: bool = True
    require_type: bool = True
    allowed_types: List[str] = None
    require_scope: bool = False
    max_length: int = 72
    min_length: int = 10
    pattern: str = ""
    
    def __post_init__(self):
        if self.allowed_types is None:
            self.allowed_types = ["feat", "fix", "docs", "style", "refactor", 
                                  "test", "chore", "perf", "ci", "build"]

# ============================================================================
# Git Hooks Manager
# ============================================================================

class GitHooksManager:
    """Main class for managing Git hooks"""
    
    def __init__(self, repo_path: str = "."):
        self.repo_path = Path(repo_path).resolve()
        self.git_dir = self._find_git_dir()
        self.hooks_dir = self.git_dir / "hooks" if self.git_dir else None
    
    def _find_git_dir(self) -> Optional[Path]:
        """Find the .git directory"""
        current = self.repo_path
        
        while current != current.parent:
            git_dir = current / ".git"
            if git_dir.exists():
                return git_dir
            current = current.parent
        
        return None
    
    def is_git_repo(self) -> bool:
        """Check if current directory is a git repository"""
        return self.git_dir is not None
    
    def ensure_hooks_dir(self) -> Path:
        """Ensure hooks directory exists"""
        if not self.hooks_dir:
            raise RuntimeError("Not a git repository")
        
        self.hooks_dir.mkdir(parents=True, exist_ok=True)
        return self.hooks_dir
    
    # ========================================================================
    # Hook Management
    # ========================================================================
    
    def list_hooks(self) -> Dict[str, Dict[str, Any]]:
        """List all hooks in the repository"""
        if not self.hooks_dir:
            return {}
        
        hooks = {}
        for hook_file in self.hooks_dir.iterdir():
            if hook_file.is_file() and not hook_file.name.endswith(".sample"):
                stat_info = hook_file.stat()
                hooks[hook_file.name] = {
                    "path": str(hook_file),
                    "size": stat_info.st_size,
                    "executable": os.access(hook_file, os.X_OK),
                    "modified": stat_info.st_mtime
                }
        
        return hooks
    
    def get_hook_path(self, hook_type: HookType) -> Path:
        """Get path for a specific hook"""
        return self.ensure_hooks_dir() / hook_type.value
    
    def create_hook(self, hook_type: HookType, content: str,
                    make_executable: bool = True) -> Path:
        """Create a hook file"""
        hook_path = self.get_hook_path(hook_type)
        
        with open(hook_path, 'w') as f:
            f.write(content)
        
        if make_executable:
            self._make_executable(hook_path)
        
        return hook_path
    
    def _make_executable(self, path: Path) -> None:
        """Make file executable"""
        current_mode = path.stat().st_mode
        path.chmod(current_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    
    def delete_hook(self, hook_type: HookType) -> bool:
        """Delete a hook"""
        hook_path = self.get_hook_path(hook_type)
        
        if hook_path.exists():
            hook_path.unlink()
            return True
        return False
    
    def enable_hook(self, hook_type: HookType) -> bool:
        """Enable a hook (make executable)"""
        hook_path = self.get_hook_path(hook_type)
        
        if hook_path.exists():
            self._make_executable(hook_path)
            return True
        return False
    
    def disable_hook(self, hook_type: HookType) -> bool:
        """Disable a hook (remove executable bit)"""
        hook_path = self.get_hook_path(hook_type)
        
        if hook_path.exists():
            current_mode = hook_path.stat().st_mode
            hook_path.chmod(current_mode & ~stat.S_IXUSR & ~stat.S_IXGRP & ~stat.S_IXOTH)
            return True
        return False
    
    def read_hook(self, hook_type: HookType) -> Optional[str]:
        """Read hook content"""
        hook_path = self.get_hook_path(hook_type)
        
        if hook_path.exists():
            with open(hook_path, 'r') as f:
                return f.read()
        return None
    
    def update_hook(self, hook_type: HookType, content: str) -> bool:
        """Update hook content"""
        hook_path = self.get_hook_path(hook_type)
        
        if hook_path.exists():
            with open(hook_path, 'w') as f:
                f.write(content)
            return True
        return False
    
    # ========================================================================
    # Pre-configured Hooks
    # ========================================================================
    
    def create_pre_commit_hook(self, lint_cmd: str = "",
                               test_cmd: str = "",
                               secret_check: str = "",
                               use_python: bool = False) -> Path:
        """Create pre-commit hook"""
        if use_python:
            content = PYTHON_HOOK_TEMPLATE.format(
                hook_name="pre-commit",
                hook_logic=f'''
    # Run linting
    if "{lint_cmd}":
        result = subprocess.run("{lint_cmd}", shell=True)
        if result.returncode != 0:
            print("Linting failed!")
            return 1
    
    # Run tests
    if "{test_cmd}":
        result = subprocess.run("{test_cmd}", shell=True)
        if result.returncode != 0:
            print("Tests failed!")
            return 1
    
    return 0
'''
            )
        else:
            content = PRE_COMMIT_HOOK_TEMPLATE.format(
                lint_command=lint_cmd or "true",
                test_command=test_cmd or "true",
                secret_check_command=secret_check or "true"
            )
        
        return self.create_hook(HookType.PRE_COMMIT, content)
    
    def create_pre_push_hook(self, test_cmd: str = "",
                             branch_check: str = "",
                             use_python: bool = False) -> Path:
        """Create pre-push hook"""
        if use_python:
            content = PYTHON_HOOK_TEMPLATE.format(
                hook_name="pre-push",
                hook_logic=f'''
    # Run tests
    if "{test_cmd}":
        result = subprocess.run("{test_cmd}", shell=True)
        if result.returncode != 0:
            print("Tests failed!")
            return 1
    return 0
'''
            )
        else:
            content = PRE_PUSH_HOOK_TEMPLATE.format(
                test_command=test_cmd or "true",
                branch_check_command=branch_check or "true"
            )
        
        return self.create_hook(HookType.PRE_PUSH, content)
    
    def create_commit_msg_hook(self, config: CommitMessageConfig) -> Path:
        """Create commit-msg hook for message validation"""
        type_pattern = "(" + "|".join(config.allowed_types) + ")" if config.require_type else ""
        scope_pattern = "\\(.+\\)" if config.require_scope else "(\\(.+\\))?"
        pattern = f"^{type_pattern}{scope_pattern}: .{{{config.min_length},{config.max_length}}}$"
        
        validation_logic = f'''
if ! echo "$COMMIT_MSG" | grep -qE "{pattern}"; then
    exit 1
fi
'''
        
        content = COMMIT_MSG_HOOK_TEMPLATE.format(
            validation_logic=validation_logic,
            format_pattern=pattern
        )
        
        return self.create_hook(HookType.COMMIT_MSG, content)
    
    # ========================================================================
    # Husky Integration
    # ========================================================================
    
    def setup_husky(self, pre_commit: str = "",
                    pre_push: str = "",
                    commit_msg: str = "",
                    post_checkout: str = "",
                    post_merge: str = "") -> Path:
        """Setup Husky configuration"""
        husky_dir = self.repo_path / ".husky"
        husky_dir.mkdir(exist_ok=True)
        
        # Create Husky config
        config = HUSKY_CONFIG_TEMPLATE.format(
            pre_commit_cmd=pre_commit or "echo 'No pre-commit command'",
            pre_push_cmd=pre_push or "echo 'No pre-push command'",
            commit_msg_cmd=commit_msg or "echo 'No commit-msg command'",
            post_checkout_cmd=post_checkout or "",
            post_merge_cmd=post_merge or ""
        )
        
        config_path = self.repo_path / ".huskyrc.json"
        with open(config_path, 'w') as f:
            f.write(config)
        
        # Create Husky hooks directory structure
        for hook_type in HookType:
            hook_path = husky_dir / hook_type.value
            if not hook_path.exists():
                hook_path.write_text('#!/bin/sh\n. "$(dirname "$0")/_/husky.sh"\n')
                self._make_executable(hook_path)
        
        return config_path
    
    def install_husky(self) -> bool:
        """Install Husky via npm/npx"""
        try:
            result = subprocess.run(
                ["npx", "husky", "install"],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            return result.returncode == 0
        except FileNotFoundError:
            print("npx not found. Please install Node.js")
            return False
    
    def add_husky_hook(self, hook_type: HookType, command: str) -> Path:
        """Add a command to Husky hook"""
        try:
            result = subprocess.run(
                ["npx", "husky", "add", f".husky/{hook_type.value}", command],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            hook_path = self.repo_path / ".husky" / hook_type.value
            if hook_path.exists():
                return hook_path
        except FileNotFoundError:
            pass
        return None
    
    # ========================================================================
    # Utilities
    # ========================================================================
    
    def run_hook(self, hook_type: HookType) -> Tuple[bool, str]:
        """Manually run a hook for testing"""
        hook_path = self.get_hook_path(hook_type)
        
        if not hook_path.exists():
            return False, f"Hook {hook_type.value} does not exist"
        
        try:
            result = subprocess.run(
                [str(hook_path)],
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )
            return result.returncode == 0, result.stderr or result.stdout
        except Exception as e:
            return False, str(e)
    
    def test_commit_msg(self, message: str, config: CommitMessageConfig = None) -> bool:
        """Test commit message against validation rules"""
        config = config or CommitMessageConfig()
        
        # Check length
        if len(message) > config.max_length:
            print(f"Message too long: {len(message)} > {config.max_length}")
            return False
        
        if len(message) < config.min_length:
            print(f"Message too short: {len(message)} < {config.min_length}")
            return False
        
        # Check type prefix
        if config.require_type:
            import re
            type_pattern = "^(" + "|".join(config.allowed_types) + ")"
            if not re.match(type_pattern, message):
                print(f"Message must start with one of: {', '.join(config.allowed_types)}")
                return False
        
        # Check custom pattern
        if config.pattern and not re.match(config.pattern, message):
            print(f"Message does not match required pattern")
            return False
        
        return True
    
    def generate_sample_hooks(self) -> List[Path]:
        """Generate sample hook files"""
        created = []
        
        # Pre-commit with common checks
        pre_commit = self.create_pre_commit_hook(
            lint_cmd="echo 'Running linter...'",
            test_cmd="echo 'Running tests...'"
        )
        created.append(pre_commit)
        
        # Pre-push with test suite
        pre_push = self.create_pre_push_hook(
            test_cmd="echo 'Running full test suite...'"
        )
        created.append(pre_push)
        
        # Commit message validation
        commit_msg = self.create_commit_msg_hook(CommitMessageConfig())
        created.append(commit_msg)
        
        return created

# ============================================================================
# CLI Interface
# ============================================================================

def main():
    parser = argparse.ArgumentParser(description="Git Hooks Manager")
    parser.add_argument("--repo", default=".", help="Repository path")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # List hooks
    subparsers.add_parser("list", help="List all hooks")
    
    # Create hooks
    precommit_parser = subparsers.add_parser("create-pre-commit", help="Create pre-commit hook")
    precommit_parser.add_argument("--lint", default="", help="Lint command")
    precommit_parser.add_argument("--test", default="", help="Test command")
    
    prepush_parser = subparsers.add_parser("create-pre-push", help="Create pre-push hook")
    prepush_parser.add_argument("--test", default="", help="Test command")
    
    commitmsg_parser = subparsers.add_parser("create-commit-msg", help="Create commit-msg hook")
    commitmsg_parser.add_argument("--types", default="feat,fix,docs", help="Allowed types")
    commitmsg_parser.add_argument("--max-len", type=int, default=72, help="Max message length")
    
    # Manage hooks
    enable_parser = subparsers.add_parser("enable", help="Enable hook")
    enable_parser.add_argument("hook", choices=[h.value for h in HookType], help="Hook type")
    
    disable_parser = subparsers.add_parser("disable", help="Disable hook")
    disable_parser.add_argument("hook", choices=[h.value for h in HookType], help="Hook type")
    
    delete_parser = subparsers.add_parser("delete", help="Delete hook")
    delete_parser.add_argument("hook", choices=[h.value for h in HookType], help="Hook type")
    
    run_parser = subparsers.add_parser("run", help="Run hook manually")
    run_parser.add_argument("hook", choices=[h.value for h in HookType], help="Hook type")
    
    # Husky
    subparsers.add_parser("setup-husky", help="Setup Husky configuration")
    subparsers.add_parser("install-husky", help="Install Husky")
    
    # Test
    testmsg_parser = subparsers.add_parser("test-msg", help="Test commit message")
    testmsg_parser.add_argument("message", help="Commit message to test")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    manager = GitHooksManager(args.repo)
    
    if not manager.is_git_repo():
        print("Not a git repository")
        return
    
    if args.command == "list":
        hooks = manager.list_hooks()
        if hooks:
            for name, info in hooks.items():
                status = "executable" if info["executable"] else "disabled"
                print(f"{name} ({status})")
        else:
            print("No hooks configured")
    
    elif args.command == "create-pre-commit":
        path = manager.create_pre_commit_hook(lint_cmd=args.lint, test_cmd=args.test)
        print(f"Created: {path}")
    
    elif args.command == "create-pre-push":
        path = manager.create_pre_push_hook(test_cmd=args.test)
        print(f"Created: {path}")
    
    elif args.command == "create-commit-msg":
        config = CommitMessageConfig(
            allowed_types=args.types.split(","),
            max_length=args.max_len
        )
        path = manager.create_commit_msg_hook(config)
        print(f"Created: {path}")
    
    elif args.command == "enable":
        if manager.enable_hook(HookType(args.hook)):
            print(f"Enabled {args.hook}")
    
    elif args.command == "disable":
        if manager.disable_hook(HookType(args.hook)):
            print(f"Disabled {args.hook}")
    
    elif args.command == "delete":
        if manager.delete_hook(HookType(args.hook)):
            print(f"Deleted {args.hook}")
    
    elif args.command == "run":
        success, output = manager.run_hook(HookType(args.hook))
        print(output)
        print("Success" if success else "Failed")
    
    elif args.command == "setup-husky":
        path = manager.setup_husky()
        print(f"Created Husky config: {path}")
    
    elif args.command == "install-husky":
        if manager.install_husky():
            print("Husky installed")
        else:
            print("Failed to install Husky")
    
    elif args.command == "test-msg":
        config = CommitMessageConfig()
        if manager.test_commit_msg(args.message, config):
            print("Valid commit message")
        else:
            print("Invalid commit message")

if __name__ == "__main__":
    main()
